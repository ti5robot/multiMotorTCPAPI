#include "mathfunc.h"
#include <math.h>

extern "C"
{ // 添加extern "C"
	/*这段代码实现了计算两个三维向量的点积。点积（Dot Product）是一种向量运算，用于衡量两个向量之间的相似性或夹角的余弦值。

	具体来说，函数vec_dot接受两个三维向量v1和v2作为输入参数。然后，它通过将两个向量对应位置的分量相乘，并将结果相加，来计算两个向量的点积。点积的计算公式为：

	dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]

	最后，函数返回计算得到的点积结果。

	点积在几何和向量计算中有广泛的应用，例如计算向量长度、判断向量是否正交、计算向量之间的夹角等。*/
	float vec_dot(float v1[3], float v2[3])
	{
		return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
	}
	float vec_length(float v[3])
	{
		return sqrt(vec_dot(v, v));
	}
	/*
	具体来说，函数接受三个参数：输入向量v、目标长度l和输出向量nv。它通过计算输入向量v的长度（使用函数vec_length）与目标长度l的比例因子k。
	然后，将输入向量v的每个分量与k相乘，得到缩放后的结果，分别保存在输出向量nv的对应分量中。
	这段代码的作用是将输入向量v按照目标长度l进行缩放，使得缩放后的向量nv的长度等于l。通过改变向量的模来实现缩放，保持向量的方向不变。
	*/
	void vec_rescale(float v[3], float l, float nv[3])
	{
		float k = l / vec_length(v);
		nv[0] = v[0] * k, nv[1] = v[1] * k, nv[2] = v[2] * k;
	};
	int fx2solv(float a, float b, float c, float *p1, float *p2)
	{
		float m1 = b / a, m2 = m1 * m1 - c / a;
		if (m2 < 0)
			return 0;
		else if (m2 == 0)
		{
			*p1 = -m1;
			return 1;
		}
		else
		{
			*p1 = sqrt(m2) - m1;
			*p2 = -sqrt(m2) - m1;
			return 2;
		}
	}
	/*计算两点之间的距离*/
	float pointsdistance(float P1[3], float P2[3])
	{
		return sqrt((P2[0] - P1[0]) * (P2[0] - P1[0]) + (P2[1] - P1[1]) * (P2[1] - P1[1]) + (P2[2] - P1[2]) * (P2[2] - P1[2]));
	}
	/*计算两个向量v1和v2的差值，并将结果存储在向量v中。函数的输入参数包括两个向量v1和v2的坐标，以及一个输出向量v。
	函数内部通过赋值语句计算v[0]=v1[0]-v2[0]，v[1]=v1[1]-v2[1]，v[2]=v1[2]-v2[2]来实现差值计算。*/
	void vec_subtraction(float v1[3], float v2[3], float v[3])
	{
		v[0] = v1[0] - v2[0], v[1] = v1[1] - v2[1], v[2] = v1[2] - v2[2];
	}

	/*用于将两个向量v1和v2的坐标相加，并将结果存储在向量v中。函数的输入参数包括两个向量v1和v2的坐标，以及一个输出向量v。
	函数内部通过赋值语句计算v[0]=v1[0]+v2[0]，v[1]=v1[1]+v2[1]，v[2]=v1[2]+v2[2]来实现向量加法。*/
	void vec_addition(float v1[3], float v2[3], float v[3])
	{
		v[0] = v1[0] + v2[0], v[1] = v1[1] + v2[1], v[2] = v1[2] + v2[2];
	}
	float vec_angle(float v1[3], float v2[3], float f)
	{
		float e1[3], e2[3];
		vec_rescale(v1, 1, e1);
		vec_rescale(v2, 1, e2);
		float c = vec_dot(e1, e2);
		if (c > 1)
			c = 1;
		else if (c < -1)
			c = -1;
		float angle = acos(c);
		if (f < 0)
			angle = -angle;
		return angle;
	};
	float solve_trangle(float a, float b, float c)
	{
		return acos((a * a + b * b - c * c) / (2 * a * b));
	};

	/*计算两个向量v1和v2的叉积，并将结果存储在向量v中。函数的输入参数包括两个向量v1和v2的坐标，以及一个输出向量v。*/
	void vec_cross(float v1[3], float v2[3], float v[3])
	{
		v[0] = v1[1] * v2[2] - v1[2] * v2[1]; // 叉积计算
		v[1] = v1[2] * v2[0] - v1[0] * v2[2];
		v[2] = v1[0] * v2[1] - v1[1] * v2[0];
	}
	float calcu_angle(float sa, float ca, float cp2)
	{
		float a;
		if (abs(ca) < abs(sa))
		{
			a = acos(ca / cp2);
			a = sa < 0 ? -a : a; // if near 0 then =0
		}
		else
		{
			sa /= cp2;
			a = asin(sa);
			if (ca < 0)
				a = sa > 0 ? pi - a : -pi - a; //[-pi,pi)
		}
		return a;
	};

	// 矩阵
	void MatrixmultPoint(float P0[3], float T[4][4], float P[3])
	{
		P[0] = T[0][0] * P0[0] + T[0][1] * P0[1] + T[0][2] * P0[2] + T[0][3];
		P[1] = T[1][0] * P0[0] + T[1][1] * P0[1] + T[1][2] * P0[2] + T[1][3];
		P[2] = T[2][0] * P0[0] + T[2][1] * P0[1] + T[2][2] * P0[2] + T[2][3];
	}
	void Matrixmult(float T1[4][4], float T2[4][4], float T[4][4])
	{
		T[0][0] = T1[0][0] * T2[0][0] + T1[0][1] * T2[1][0] + T1[0][2] * T2[2][0];
		T[0][1] = T1[0][0] * T2[0][1] + T1[0][1] * T2[1][1] + T1[0][2] * T2[2][1];
		T[0][2] = T1[0][0] * T2[0][2] + T1[0][1] * T2[1][2] + T1[0][2] * T2[2][2];
		T[0][3] = T1[0][0] * T2[0][3] + T1[0][1] * T2[1][3] + T1[0][2] * T2[2][3] + T1[0][3];
		T[1][0] = T1[1][0] * T2[0][0] + T1[1][1] * T2[1][0] + T1[1][2] * T2[2][0];
		T[1][1] = T1[1][0] * T2[0][1] + T1[1][1] * T2[1][1] + T1[1][2] * T2[2][1];
		T[1][2] = T1[1][0] * T2[0][2] + T1[1][1] * T2[1][2] + T1[1][2] * T2[2][2];
		T[1][3] = T1[1][0] * T2[0][3] + T1[1][1] * T2[1][3] + T1[1][2] * T2[2][3] + T1[1][3];
		T[2][0] = T1[2][0] * T2[0][0] + T1[2][1] * T2[1][0] + T1[2][2] * T2[2][0];
		T[2][1] = T1[2][0] * T2[0][1] + T1[2][1] * T2[1][1] + T1[2][2] * T2[2][1];
		T[2][2] = T1[2][0] * T2[0][2] + T1[2][1] * T2[1][2] + T1[2][2] * T2[2][2];
		T[2][3] = T1[2][0] * T2[0][3] + T1[2][1] * T2[1][3] + T1[2][2] * T2[2][3] + T1[2][3];
		T[3][0] = T[3][1] = T[3][2] = 0;
		T[3][3] = 1;
	}
	void MatrixT2MatrixI(float T[4][4], float I[4][4])
	{
		I[0][0] = (T[1][1] * T[2][2] - T[1][2] * T[2][1]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[0][1] = (-T[0][1] * T[2][2] + T[0][2] * T[2][1]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[0][2] = (T[0][1] * T[1][2] - T[0][2] * T[1][1]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[0][3] = (-T[0][1] * T[1][2] * T[2][3] + T[0][1] * T[1][3] * T[2][2] + T[0][2] * T[1][1] * T[2][3] - T[0][2] * T[1][3] * T[2][1] - T[0][3] * T[1][1] * T[2][2] + T[0][3] * T[1][2] * T[2][1]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[1][0] = (-T[1][0] * T[2][2] + T[1][2] * T[2][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[1][1] = (T[0][0] * T[2][2] - T[0][2] * T[2][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[1][2] = (-T[0][0] * T[1][2] + T[0][2] * T[1][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[1][3] = (T[0][0] * T[1][2] * T[2][3] - T[0][0] * T[1][3] * T[2][2] - T[0][2] * T[1][0] * T[2][3] + T[0][2] * T[1][3] * T[2][0] + T[0][3] * T[1][0] * T[2][2] - T[0][3] * T[1][2] * T[2][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[2][0] = (T[1][0] * T[2][1] - T[1][1] * T[2][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[2][1] = (-T[0][0] * T[2][1] + T[0][1] * T[2][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[2][2] = (T[0][0] * T[1][1] - T[0][1] * T[1][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[2][3] = (-T[0][0] * T[1][1] * T[2][3] + T[0][0] * T[1][3] * T[2][1] + T[0][1] * T[1][0] * T[2][3] - T[0][1] * T[1][3] * T[2][0] - T[0][3] * T[1][0] * T[2][1] + T[0][3] * T[1][1] * T[2][0]) / (T[0][0] * T[1][1] * T[2][2] - T[0][0] * T[1][2] * T[2][1] - T[0][1] * T[1][0] * T[2][2] + T[0][1] * T[1][2] * T[2][0] + T[0][2] * T[1][0] * T[2][1] - T[0][2] * T[1][1] * T[2][0]);
		I[3][0] = I[3][1] = I[3][2] = 0;
		I[3][3] = 1;
	}
} // 添加extern "C"